import numpy as np

from config import BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS, BETA_CONSTRAINTS, X_DOT, Y_DOT, ALPHA_DOT, V_DOT, is_feasible, \
    s_0, s_f, NUM_OPTIMIZATION_PARAMETERS, K
from scipy.interpolate import CubicSpline


def encode_to_binary(v, s, ub, lb):
    R = ub - lb
    encoded = ((v - lb) / R) * (2 ** s - 1)

    if v < 0:  # Check if negative
        encoded *= -1

    decimal = int(encoded)
    return bin(decimal).replace("-", "")[2:].zfill(s)


def decode_to_actual(b, s, ub, lb):
    decimal = int(b, 2)

    R = ub - lb
    actual = (decimal / (2 ** s - 1)) * R + lb
    return actual


# From https://stackoverflow.com/questions/18854620/whats-the-best-way-to-split-a-string-into-fixed-length-chunks-and-work-with-the
def chunk_string(string, length):
    return (string[0 + i:length + i] for i in range(0, len(string), length))


def binary_string_to_individual(string):
    individual = Individual()
    binary_array = list(chunk_string(string, BINARY_CODE_LENGTH))

    gamma = 0.0
    for num, v in enumerate(binary_array):
        if num % 2 == 0:
            gamma = decode_to_actual(v, BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS[1], GAMMA_CONSTRAINTS[0])
        else:
            beta = decode_to_actual(v, BINARY_CODE_LENGTH, BETA_CONSTRAINTS[1], BETA_CONSTRAINTS[0])
            individual.add_parameter(gamma, beta)

    return individual


def eulers(gamma_interpolation, beta_interpolation):
    x_new = np.linspace(0, NUM_OPTIMIZATION_PARAMETERS, 100)  # Get 100 samples
    h = x_new[1]
    gamma_new = gamma_interpolation(x_new)
    beta_new = beta_interpolation(x_new)

    solution = [s_0]
    for i in range(1, len(x_new)):
        prev = solution[i - 1]

        next_state = [
            prev[0] + h * X_DOT(prev[3], prev[2]),  # x_dot(v, alpha)
            prev[1] + h * Y_DOT(prev[3], prev[2]),  # y_dot(v, alpha)
            prev[2] + h * ALPHA_DOT(gamma_new[i]),  # alpha_dot(gamma)
            prev[3] + h * V_DOT(beta_new[i])  # v_dot(beta)
        ]
        solution.append(next_state)

    return solution  # Return list of states


class Individual:

    def __init__(self):
        self.gammas = []
        self.betas = []

    def __str__(self):
        out = []
        j = 0
        for gamma, beta in zip(self.gammas, self.betas):
            out.append(f"    gamma_{j}: {gamma}")
            out.append(f"    beta_{j}:  {beta}")
            j += 1

        return "{\n" + ",\n".join(out) + "\n}"

    def add_parameter(self, gamma, beta):
        self.gammas.append(gamma)
        self.betas.append(beta)

    def get_binary_string(self):
        binary = ""
        for gamma, beta in zip(self.gammas, self.betas):
            binary += (encode_to_binary(gamma, BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS[1], GAMMA_CONSTRAINTS[0]))
            binary += (encode_to_binary(beta, BINARY_CODE_LENGTH, BETA_CONSTRAINTS[1], BETA_CONSTRAINTS[0]))
        return binary

    # Get the final state from the individuals
    def get_s_f(self):
        x = np.arange(0, NUM_OPTIMIZATION_PARAMETERS)
        gamma_interpolation = CubicSpline(x, self.gammas, bc_type='natural')
        beta_interpolation = CubicSpline(x, self.betas, bc_type='natural')

        return eulers(gamma_interpolation, beta_interpolation)[::-1][0]  # Get last state generated by eulers method

    # Cost function to be optimized
    def J(self):
        individual_s_f = self.get_s_f()
        if is_feasible(individual_s_f[0], individual_s_f[1]):  # x & y of this individual
            return np.linalg.norm(s_f - individual_s_f)
        else:
            return K

    # Fitness function of the individual (higher g is better)
    def g(self):
        return 1 / (self.J() + 1)
