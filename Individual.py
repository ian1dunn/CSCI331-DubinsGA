import numpy as np

from config import BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS, BETA_CONSTRAINTS, X_DOT, Y_DOT, ALPHA_DOT, V_DOT, is_feasible, \
    s_0, s_f, NUM_OPTIMIZATION_PARAMETERS, K
from scipy.interpolate import CubicSpline


# Encode a float value to binary
# v  = value
# s  = size of binary string
# ub = upper bound of allowed float values
# lb = lower bound of allowed float values
def encode_to_binary(v, s, ub, lb):
    R = ub - lb
    encoded = ((v - lb) / R) * (2 ** s - 1)

    if v < 0:  # Check if negative
        encoded *= -1

    decimal = int(encoded)
    return bin(decimal).replace("-", "")[2:].zfill(s)


# Decode a float value from binary
# b  = binary string
# s  = size of binary string
# ub = upper bound of allowed float values
# lb = lower bound of allowed float values
def decode_to_actual(b, s, ub, lb):
    decimal = int(b, 2)

    R = ub - lb
    actual = (decimal / (2 ** s - 1)) * R + lb
    return actual


# https://stackoverflow.com/questions/18854620/whats-the-best-way-to-split-a-string-into-fixed-length-chunks-and-work-with-the
# Function to break down a string into chunks of given length
def chunk_string(string, length):
    return (string[0 + i:length + i] for i in range(0, len(string), length))


# Convert a binary string to an Individual
def binary_string_to_individual(string):
    individual = Individual()
    binary_array = list(chunk_string(string, BINARY_CODE_LENGTH))

    gamma = 0.0
    for num, v in enumerate(binary_array):
        if num % 2 == 0:
            gamma = decode_to_actual(v, BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS[1], GAMMA_CONSTRAINTS[0])
        else:
            beta = decode_to_actual(v, BINARY_CODE_LENGTH, BETA_CONSTRAINTS[1], BETA_CONSTRAINTS[0])
            individual.add_parameter(gamma, beta)

    return individual


# Use eulers method on given gamma and beta interpolations to find a list of states to the final state
# given an initial state
def eulers(gamma_interpolation, beta_interpolation):
    x_new = np.linspace(0, NUM_OPTIMIZATION_PARAMETERS, 100)  # Get 100 samples
    h = x_new[1]
    gamma_new = gamma_interpolation(x_new)
    beta_new = beta_interpolation(x_new)

    solution = [s_0]
    for i in range(1, len(x_new)):
        prev = solution[i - 1]

        next_state = [
            prev[0] + h * X_DOT(prev[3], prev[2]),  # x_dot(v, alpha)
            prev[1] + h * Y_DOT(prev[3], prev[2]),  # y_dot(v, alpha)
            prev[2] + h * ALPHA_DOT(gamma_new[i]),  # alpha_dot(gamma)
            prev[3] + h * V_DOT(beta_new[i])        # v_dot(beta)
        ]
        solution.append(next_state)

    return solution  # Return list of states


# Get the final state of an array of states of arbitrary length
def get_s_f(states):
    return states[::-1][0]  # Get last state generated by eulers method


class Individual:

    def __init__(self):
        self.gammas = []
        self.betas = []

    def __str__(self):
        out = []
        j = 0
        for gamma, beta in zip(self.gammas, self.betas):
            out.append(f"    gamma_{j}: {gamma}")
            out.append(f"    beta_{j}:  {beta}")
            j += 1

        return "{\n" + ",\n".join(out) + "\n}"

    def add_parameter(self, gamma, beta):
        self.gammas.append(gamma)
        self.betas.append(beta)

    def get_binary_string(self):
        binary = ""
        for gamma, beta in zip(self.gammas, self.betas):
            binary += (encode_to_binary(gamma, BINARY_CODE_LENGTH, GAMMA_CONSTRAINTS[1], GAMMA_CONSTRAINTS[0]))
            binary += (encode_to_binary(beta, BINARY_CODE_LENGTH, BETA_CONSTRAINTS[1], BETA_CONSTRAINTS[0]))
        return binary

    def get_individual_array(self):
        return [str(parameter) for pair in zip(self.gammas, self.betas) for parameter in pair]

    def get_control_interpolations(self):
        x = np.arange(0, NUM_OPTIMIZATION_PARAMETERS)
        gamma_interpolation = CubicSpline(x, self.gammas, bc_type='natural')
        beta_interpolation = CubicSpline(x, self.betas, bc_type='natural')

        return gamma_interpolation, beta_interpolation

    def get_states(self):
        interpolations = self.get_control_interpolations()

        return eulers(interpolations[0], interpolations[1])  # Get all states from eulers method

    # Cost function to be optimized
    def J(self):
        states = self.get_states()

        # Check all states to make sure in bounds
        for state in states:
            if not is_feasible(state[0], state[1]):  # x & y of this individual
                return K

        return np.linalg.norm(s_f - get_s_f(states))  # otherwise return the distance between expected and actual

    # Fitness function of the individual (higher g is better)
    def g(self):
        return 1 / (self.J() + 1)
